[{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"GWAS file handling in R","text":"R isnt well know GWAS (GWAS tools standalone commandline apps) prepared vignette. vignette go trough running Quantile GWAS directly genotypes PLINK .fam/.bim/.bed dataset, using bigsnpr load genotypes fungwas quantile regression workflow.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"example-2-gwas-from-plink-files","dir":"Articles","previous_headings":"","what":"Example 2: GWAS from PLINK files","title":"GWAS file handling in R","text":"handling PLINK genotype files R done highly optimized tool bigsnpr. expedience, analyze first 1000 SNPs. practice can chunk genome manageable subsets itterte . try tutorial yourselve can download plinkfiles testun 200 Mb files.","code":"# ============================================================ # Load PLINK bed/bim/fam with bigsnpr # Simulate phenotype # Run Quantile GWAS with fungwas # ============================================================  plink_prefix <- \"/path/to/your-plink/1KG.EAS.auto.snp.norm.nodup.split.rare002.common015.missing/1KG.EAS.auto.snp.norm.nodup.split.rare002.common015.missing\"   # without extension  # Convert to .rds format, runonly  once snp_readBed(paste0(plink_prefix, \".bed\"))    obj.bigSNP <- snp_attach(paste0(plink_prefix, \".rds\"))  G   <- obj.bigSNP$genotypes     # Filebacked Big Matrix G   <- snp_fastImputeSimple(G)  # quick mean imputation, for the benefit of simulation CHR <- obj.bigSNP$map$chromosome POS <- obj.bigSNP$map$physical.pos SNP <- obj.bigSNP$map$marker.ID N   <- nrow(G) P   <- ncol(G)  cat(\"Loaded\", N, \"individuals and\", P, \"SNPs\\\\n\")  # Simulate phenotype target_snps <- sample(P, 5) beta        <- rnorm(5, 0, 0.25) genetic     <- big_prodVec(G, beta, ind.col = target_snps) y <- as.numeric(scale(genetic + rnorm(N)))  # Stage 1: Quantile GWAS taus   <- seq(0.1, 0.9, 0.1) stage1 <- quantile_gwas(   Y = y,   G = as.matrix(G[, 1:1000]),   # only first 1000 SNPs here   taus = taus,   benchmark = FALSE,   verbose = TRUE )  # Stage 2: Parametric mapping (vQTL) W_vqtl <- make_weights_vqtl(taus, stage1$q_tau, mu = mean(y), sd = sd(y))  fit <- param_gwas(   stage1,   transform = \"custom_W\",   transform_args = list(W = W_vqtl),   se_mode = \"dwls\" )  # Collect results res <- data.frame(   SNP = SNP[1:1000],   CHR = CHR[1:1000],   POS = POS[1:1000],   beta_mu = fit$params[\"beta_mu\", ],   beta_sd = fit$params[\"beta_sigma2\", ],   se_mu   = fit$SE_params[\"beta_mu\", ],   se_sd   = fit$SE_params[\"beta_sigma2\", ],   Q       = fit$Q )  head(res)  # Simple Manhattan-style plot for mean effect par(mar = c(4,4,2,1), bg = \"white\") plot(   res$POS,   -log10(pchisq((res$beta_mu/res$se_mu)^2, df=1, lower.tail = FALSE)),   col = res$CHR, pch = 20, cex = 0.6,   xlab = \"Genomic position\", ylab = \"-log10(p)\",   main = \"Quantile GWAS (mu effect)\" )"},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"chunking-the-gwas","dir":"Articles","previous_headings":"","what":"Chunking the GWAS","title":"GWAS file handling in R","text":"example analyzed first 1000 SNPs speed. practice, can loop chunks SNPs process parallel using future.apply big_apply bigsnpr. workflow : Select block SNPs G matrix. Run quantile_gwas() block. Map results param_gwas(). Save results per chunk, combine. strategy readily scales quantile GWAS genome-wide data.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/Q-stat.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Model Fit Diagnostics with the Q Statistic","text":"vignette show use Q statistic fungwas compare parametric mappings quantile GWAS slopes competing distributional models. Q statistic defined [ Q = (b - W ){-1} (b - W ),] : observed quantile slopes, (W ) slopes implied fitted parametric model, () estimated covariance slopes. small Q indicates model consistent observed slopes. larger Q indicates misfit. Important caveat: covariance estimates () used approximate (especially diagonal plugin modes), Q statistic interpreted heuristically. formal likelihood-ratio test. practice, main diagnostic whether model’s average Q much smaller alternative model. Absolute calibration chi-square reference distributions unreliable.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/Q-stat.html","id":"example-vqtl-vs-log-normal-model","dir":"Articles","previous_headings":"","what":"Example: vQTL vs Log-normal Model","title":"Model Fit Diagnostics with the Q Statistic","text":"simulate phenotypes mean + variance QTL model, compare fit log-normal model SNP influences mean (variance tied log-normal link).","code":"# ------------------------- # 1. Simulate genotypes # ------------------------- N <- 15000 P <- 500 maf <- runif(P, 0.05, 0.5) G <- matrix(rbinom(N * P, 2, rep(maf, each = N)), nrow = N, ncol = P) colnames(G) <- paste0(\"SNP\", seq_len(P))  # ------------------------- # 2. Define true effects # ------------------------- beta_mu_true     <- rnorm(P) / 40 beta_sigma2_true <- rnorm(P) / 40  # ------------------------- # 3. Simulate phenotype # ------------------------- mu0 <- 4.0 sd0 <- 0.6  mu <- mu0 + G %*% beta_mu_true sigma2 <- sd0^2 + G %*% beta_sigma2_true sigma2[sigma2 <= 0] <- 1e-4  # guard against negative variances  Y <- rnorm(N, mean = mu, sd = sqrt(sigma2))"},{"path":"https://michelnivard.github.io/fungwas/articles/Q-stat.html","id":"stage-1-quantile-gwas","dir":"Articles","previous_headings":"","what":"Stage 1: Quantile GWAS","title":"Model Fit Diagnostics with the Q Statistic","text":"first compute quantile slopes using RIF regression.","code":"taus <- seq(0.05, 0.95, 0.05) stage1 <- quantile_gwas(   Y, G,   taus = taus,   benchmark = FALSE,   verbose = FALSE )"},{"path":"https://michelnivard.github.io/fungwas/articles/Q-stat.html","id":"stage-2-correct-model-mean-variance-qtl","dir":"Articles","previous_headings":"","what":"Stage 2: Correct Model (Mean + Variance QTL)","title":"Model Fit Diagnostics with the Q Statistic","text":"map slopes mean variance parameters using make_weights_vqtl.","code":"W_var <- make_weights_vqtl(taus, stage1$q_tau, mu = mean(Y), sd = sd(Y))  fit_correct <- param_gwas(   stage1,   transform = \"custom_W\",   transform_args = list(W = W_var),   se_mode = \"dwls\" )"},{"path":"https://michelnivard.github.io/fungwas/articles/Q-stat.html","id":"stage-2-wrong-model-log-normal","dir":"Articles","previous_headings":"","what":"Stage 2: Wrong Model (Log-normal)","title":"Model Fit Diagnostics with the Q Statistic","text":"now compare log-normal distribution. , effects meanlog implicitly alter mean variance, without independent variance parameter.","code":"logY <- log(Y) fitlog <- list(   estimate = c(meanlog = mean(logY), sdlog = sd(logY)) ) q_tau <- as.numeric(quantile(Y, taus, type = 8))  dist_cdf <- function(y, params) plnorm(y, meanlog = params$meanlog, sdlog = params$sdlog) dist_pdf <- function(y, params) dlnorm(y, meanlog = params$meanlog, sdlog = params$sdlog)  grad_fd_meanlog <- make_fd_grad(\"meanlog\", dist_cdf) grad_fd_sdlog   <- make_fd_grad(\"sdlog\", dist_cdf)  W_fd <- make_weights_generic(   taus, q_tau, dist_cdf, dist_pdf,   params = list(meanlog = fitlog$estimate[1], sdlog = fitlog$estimate[2]),   grad_funcs = list(beta_meanlog = grad_fd_meanlog,                     beta_sdlog   = grad_fd_sdlog) )  fit_wrong <- param_gwas(   stage1,   transform = \"custom_W\",   transform_args = list(W = W_fd),   se_mode = \"dwls\" )"},{"path":"https://michelnivard.github.io/fungwas/articles/Q-stat.html","id":"compare-q-statistics","dir":"Articles","previous_headings":"","what":"Compare Q Statistics","title":"Model Fit Diagnostics with the Q Statistic","text":"example, true vQTL model yields systematically lower Q values misspecified log-normal model, confirming variance effects necessary explain quantile slopes.","code":"cat(\"\\n--- Model Comparison ---\\n\") #>  #> --- Model Comparison --- cat(\"Correct model Q (per SNP):\\n\") #> Correct model Q (per SNP): print(summary(fit_correct$Q)) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   0.595   3.433   4.992   5.747   7.322  19.607  cat(\"\\nWrong model Q (per SNP):\\n\") #>  #> Wrong model Q (per SNP): print(summary(fit_wrong$Q)) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.6344  3.5250  5.0815  5.8670  7.2588 21.6910  cat(\"\\nAverage Q difference (wrong - correct):\\n\") #>  #> Average Q difference (wrong - correct): mean(fit_wrong$Q - fit_correct$Q) #> [1] 0.1196326  plot(fit_correct$Q - fit_wrong$Q,      main = \"Q(correct) - Q(wrong) per SNP\",      ylab = \"ΔQ\", xlab = \"SNP index\") abline(h = 0, col = \"red\")"},{"path":"https://michelnivard.github.io/fungwas/articles/Q-stat.html","id":"key-takeaways","dir":"Articles","previous_headings":"","what":"Key Takeaways","title":"Model Fit Diagnostics with the Q Statistic","text":"Q statistic fungwas heuristic measure model adequacy, calibrated chi-square test. comparing competing models, large difference average Q provides evidence model better captures distributional shape phenotype. However, SEs approximate, absolute reference chi-square distributions discouraged. practice, Q best used ask: chosen parametric system capture quantile slopes better simpler alternative?","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/Q-stat.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Model Fit Diagnostics with the Q Statistic","text":"Q statistic provides useful way compare alternative parametric models fungwas. seen diagnostic tool, helping identify whether variance effects, mixtures, parameters needed describe phenotype distribution, rather formal hypothesis test.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Functional GWAS via Quantile Regression and RIF","text":"GWAS focus mean effects: SNP increase decrease average level trait? genetic effects can subtle: SNPs may increase variability (vQTLs). Others may shift balance subtypes mixture components. may affect mean variance together. fungwas package provides fast, flexible framework test SNP effects distributional parameters, just means.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"core-idea","dir":"Articles","previous_headings":"","what":"Core idea","title":"Functional GWAS via Quantile Regression and RIF","text":"Use Recentered Influence Functions (RIFs) link SNPs changes trait quantiles. gives “SNP slopes” across distribution. fast (closed-form OLS, iterative quantile regression). Combine quantile slopes using weight matrix W map parameter interest: mean, variance, mixture membership, etc. Estimate SNP effects standard errors parameters. two-step process backbone fungwas.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"example-1-standard-mean-effect","dir":"Articles","previous_headings":"","what":"Example 1: Standard mean effect","title":"Functional GWAS via Quantile Regression and RIF","text":"Let’s simulate simple trait SNP effects mean. , column beta_mu corresponds SNP effect mean.","code":"N <- 5000 P <- 50 maf <- runif(P, 0.05, 0.5) G <- matrix(rbinom(N * P, 2, rep(maf, each = N)), N, P) colnames(G) <- paste0(\"SNP\", seq_len(P))  # Simulate a mean effect beta_true <- rnorm(P) / 40 Y <- rnorm(N, mean = 2 + G %*% beta_true, sd = 1)  taus <- seq(0.1, 0.9, 0.05)  # Stage 1: quantile GWAS stage1 <- quantile_gwas(Y, G, taus = taus) #> Building RIF matrix... #> Computing per-SNP tau-slopes...  # Stage 2: mean/variance mapping (vQTL weights) W <- make_weights_vqtl(taus, stage1$q_tau, mu = mean(Y), sd = sd(Y)) fit <- param_gwas(stage1, transform = \"custom_W\", transform_args = list(W = W))  head(t(fit$params)) #>          beta_mu  beta_sigma2 #> SNP1 -0.03798818 -0.026820633 #> SNP2 -0.01832948  0.018785274 #> SNP3  0.02361505 -0.045563528 #> SNP4  0.04302755  0.001305224 #> SNP5  0.05758468 -0.048737974 #> SNP6  0.01513990  0.199157417"},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"example-2-variance-effects-vqtls","dir":"Articles","previous_headings":"","what":"Example 2: Variance effects (vQTLs)","title":"Functional GWAS via Quantile Regression and RIF","text":"Suppose SNPs affect just mean also spread phenotype. Now obtain SNP effects mean variance.","code":"beta_mu_true     <- rnorm(P) / 40 beta_sigma2_true <- rnorm(P) / 40  mu <- 2 + G %*% beta_mu_true sigma2 <- 1 + G %*% beta_sigma2_true sigma2[sigma2 <= 0] <- 0.1  Y <- rnorm(N, mean = mu, sd = sqrt(sigma2))  taus <- seq(0.05, 0.95, 0.05) stage1 <- quantile_gwas(Y, G, taus = taus) #> Building RIF matrix... #> Computing per-SNP tau-slopes...  W_var <- make_weights_vqtl(taus, stage1$q_tau, mu = mean(Y), sd = sd(Y)) fit_var <- param_gwas(stage1, transform = \"custom_W\", transform_args = list(W = W_var))  head(t(fit_var$params)) #>          beta_mu beta_sigma2 #> SNP1 -0.01474599 -0.10471233 #> SNP2  0.03817296  0.02671172 #> SNP3 -0.06506831 -0.05781526 #> SNP4  0.01184463  0.03804201 #> SNP5 -0.01047337 -0.04669658 #> SNP6  0.01771871 -0.08678875"},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"example-3-mixture-gwas","dir":"Articles","previous_headings":"","what":"Example 3: Mixture GWAS","title":"Functional GWAS via Quantile Regression and RIF","text":"Many complex traits mixtures underlying subtypes. example, “cases” might consist two symptom clusters, biomarker distributions may show multimodality. can model SNP effects component means class membership two-Normal mixture.","code":"p1 <- 0.5 mu1 <- 1.2; sd1 <- 0.5 mu2 <- 3.0; sd2 <- 0.8  # Simulate phenotype z <- rbinom(N, 1, p1) Y <- ifelse(z == 1, rnorm(N, mu1, sd1), rnorm(N, mu2, sd2))  taus <- seq(0.1, 0.9, 0.05) stage1 <- quantile_gwas(Y, G, taus = taus) #> Building RIF matrix... #> Computing per-SNP tau-slopes...  fit_mix <- param_gwas(   stage1,   transform = \"two_normal\",   transform_args = list(     p1 = p1, mu1 = mu1, sd1 = sd1,     mu2 = mu2, sd2 = sd2,     include_membership = TRUE   ) )  head(t(fit_mix$params)) #>            gamma        beta_1        beta_2 #> SNP1 -0.05727378 -1.903029e-02 -0.0233213774 #> SNP2  0.07954904 -7.991301e-05  0.0076335131 #> SNP3 -0.06057390 -2.434824e-02  0.0003425944 #> SNP4  0.02074416 -7.745207e-04 -0.0188630721 #> SNP5 -0.12819602 -1.526194e-02 -0.0227835128 #> SNP6  0.11976032  8.322496e-02 -0.0342396586"},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"key-functions-and-workflow","dir":"Articles","previous_headings":"","what":"Key functions and workflow","title":"Functional GWAS via Quantile Regression and RIF","text":"workflow fungwas always follows two stages: Function: quantile_gwas() Y: vector phenotypes (length N). G: genotype matrix, N × P (rows = individuals, cols = SNPs). C: optional covariates (N × K, e.g. age, sex, PCs). taus: grid quantile levels (e.g. seq(0.1, 0.9, 0.05)). list containing RIF slopes per SNP × τ, SEs, baseline quantiles. Think quantile-level GWAS. Function: param_gwas() output quantile_gwas(). mapping (W) tells software combine τ-slopes parameter effects. Either supply custom W use pre-built weight constructor. SNP effects parameters (means, variances, mixture membership, etc). interpretation stage, translating distributional shifts biologically meaningful parameters.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"weight-builders","dir":"Articles","previous_headings":"Key functions and workflow","what":"Weight builders","title":"Functional GWAS via Quantile Regression and RIF","text":"Weight matrices (W) define quantile slopes correspond parameter changes.fungwas provides several ready-made constructors: make_weights_vqtl() — use want SNP effects mean variance Normal trait. Example: height variability, BMI dispersion. Component means. (Optionally) class membership probability. Example: SNPs shifting balance subtypes cases/controls. make_weights_mixture_vqtl() — extended version SNPs can also affect component variances (addition means membership). Example: genetic effects subtype prevalence within-subtype variability. provide distribution’s CDF, PDF, derivatives wrt parameters. use finite-difference helpers (make_fd_grad()). Example: log-normal GWAS meanlog sdlog. Use phenotype better described non-standard distribution.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"putting-it-together-a-typical-workflow","dir":"Articles","previous_headings":"Key functions and workflow","what":"Putting it together: a typical workflow","title":"Functional GWAS via Quantile Regression and RIF","text":"Prepare inputs: Phenotype vector Y. Genotype dosage matrix G (SNPs already QC’d). Optional covariate matrix C (e.g. sex, age, ancestry PCs). Run quantile GWAS: Choose weight system: mean & variance: two-component mixture: custom: Map parameters: Inspect results: practice: Stage 1 (quantile_gwas) run per dataset. can re-use different weight systems (param_gwas) test multiple hypotheses (means, variances, mixtures, etc) without rerunning GWAS.","code":"taus <- seq(0.1, 0.9, 0.05) stage1 <- quantile_gwas(Y, G, taus = taus, C = covariates) W <- make_weights_vqtl(taus, stage1$q_tau, mu = mean(Y), sd = sd(Y)) W <- make_weights_normal_mixture(taus, stage1$q_tau,                                  p1 = 0.5, mu1 = 1, sd1 = 1,                                  mu2 = 3, sd2 = 1.5,                                  include_membership = TRUE) W <- make_weights_generic(taus, stage1$q_tau, dist_cdf, dist_pdf, params, grad_funcs) fit <- param_gwas(stage1, transform = \"custom_W\", transform_args = list(W = W)) head(t(fit$params))   # SNP effects on chosen parameters head(t(fit$SE_params)) # Standard errors"},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"why-use-fungwas","dir":"Articles","previous_headings":"","what":"Why use fungwas?","title":"Functional GWAS via Quantile Regression and RIF","text":"Go beyond mean effects: test variance, mixtures, heterogeneity. Fast: closed-form OLS, heavy quantile regression. Flexible: distributional system can defined via make_weights_generic. Useful vQTL discovery, subtype genetics, causal inference mean effects don’t tell full story.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"Further reading","title":"Functional GWAS via Quantile Regression and RIF","text":"Koenker & Bassett (1978), Quantile Regression. Firpo, Fortin, & Lemieux (2009), Influence Function Regression. Recent applications vQTL mixture genetics GWAS.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Functional GWAS via Quantile Regression and RIF","text":"fungwas allows re-think GWAS: instead asking “SNP affect mean?”, can ask “SNP affect distribution?” — variance, mixtures, user-defined systems.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Your custom functional GWAS with `make_weights_generic`","text":"fungwas, core idea map quantile GWAS slopes parameters parametric system (means, variances, mixture components, etc). mapping accomplished weight matrices W. specific constructors built-(e.g. make_weights_normal_mixture, make_weights_vqtl), function make_weights_generic() allows define mapping distribution long can supply: CDF PDF distribution. gradients CDF wrt parameters (analytic finite-difference). vignette illustrates use log-normal phenotype.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"example-log-normal-gwas","dir":"Articles","previous_headings":"","what":"Example: Log-Normal GWAS","title":"Your custom functional GWAS with `make_weights_generic`","text":"simulate phenotypes log-normal distribution SNP effects meanlog sdlog parameters.","code":"# Simulate genotypes N <- 5000 P <- 50 maf <- runif(P, 0.05, 0.5) G <- matrix(rbinom(N * P, 2, rep(maf, each = N)), nrow = N, ncol = P) colnames(G) <- paste0(\"SNP\", seq_len(P))  # True SNP effects beta_meanlog_true <- rnorm(P) / 40 beta_sdlog_true   <- rnorm(P) / 40  # Baseline parameters meanlog0 <- 0.5 sdlog0   <- 0.7  # Individual parameters meanlog <- meanlog0 + G %*% beta_meanlog_true sdlog   <- pmax(sdlog0 + G %*% beta_sdlog_true, 0.1)  # Phenotype Y <- rlnorm(N, meanlog = meanlog, sdlog = sdlog)"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"step-1-define-distribution-and-gradients","dir":"Articles","previous_headings":"","what":"Step 1: Define distribution and gradients","title":"Your custom functional GWAS with `make_weights_generic`","text":"define CDF PDF log-normal, supply gradients CDF wrt meanlog sdlog. derivatives determine SNP effects parameters expressed quantile space.","code":"dist_cdf <- function(y, params) plnorm(y, meanlog = params$meanlog, sdlog = params$sdlog) dist_pdf <- function(y, params) dlnorm(y, meanlog = params$meanlog, sdlog = params$sdlog)  grad_meanlog <- function(y, params) {   z <- (log(y) - params$meanlog) / params$sdlog   -dnorm(z) / params$sdlog } grad_sdlog <- function(y, params) {   z <- (log(y) - params$meanlog) / params$sdlog   -(z * dnorm(z)) / params$sdlog }"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"step-2-build-weights","dir":"Articles","previous_headings":"","what":"Step 2: Build weights","title":"Your custom functional GWAS with `make_weights_generic`","text":"compute weights grid quantiles. column W corresponds mapping quantile slopes parameter-space effects.","code":"taus <- seq(0.1, 0.9, 0.05) q_tau <- as.numeric(quantile(Y, taus, type = 8))  W <- make_weights_generic(   taus, q_tau,   dist_cdf, dist_pdf,   params = list(meanlog = meanlog0, sdlog = sdlog0),   grad_funcs = list(beta_meanlog = grad_meanlog, beta_sdlog = grad_sdlog) )  head(W) #>         beta_meanlog beta_sdlog #> tau0.1     0.8193355 -0.8184712 #> tau0.15    0.9722950 -0.7335216 #> tau0.2     1.1053469 -0.6313754 #> tau0.25    1.2319771 -0.5128188 #> tau0.3     1.3678373 -0.3649568 #> tau0.35    1.4923085 -0.2124957"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"step-3-run-two-stage-gwas","dir":"Articles","previous_headings":"","what":"Step 3: Run two-stage GWAS","title":"Your custom functional GWAS with `make_weights_generic`","text":"First, run quantile GWAS estimate SNP effects quantile (RIF slopes). , map parameter-space using param_gwas() custom W.","code":"stage1 <- quantile_gwas(Y, G, taus = taus, benchmark = FALSE) #> Building RIF matrix... #> Computing per-SNP tau-slopes...  fit <- param_gwas(   stage1,   transform = \"custom_W\",   transform_args = list(W = W),   se_mode = \"diagonal\" )  head(t(fit$params)) #>      beta_meanlog  beta_sdlog #> SNP1 -0.069766804  0.03844083 #> SNP2  0.017892104 -0.01579062 #> SNP3 -0.009028385  0.02589287 #> SNP4  0.021612584 -0.02085744 #> SNP5  0.045506929 -0.01453348 #> SNP6  0.013347512 -0.03759752"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"step-4-compare-to-true-effects","dir":"Articles","previous_headings":"","what":"Step 4: Compare to true effects","title":"Your custom functional GWAS with `make_weights_generic`","text":"can check recovery correlating estimated effects truth.","code":"est <- t(fit$params)  cor_meanlog <- cor(beta_meanlog_true, est[, \"beta_meanlog\"]) cor_sdlog   <- cor(beta_sdlog_true,   est[, \"beta_sdlog\"])  cor_meanlog #> [1] 0.8096836 cor_sdlog #> [1] 0.8384027"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"finite-difference-gradients","dir":"Articles","previous_headings":"","what":"Finite-Difference Gradients","title":"Your custom functional GWAS with `make_weights_generic`","text":"Instead hand-coding gradients, can generate automatically using make_fd_grad(). Analytic FD versions give nearly identical results, making FD convenient option analytic gradients complicated.","code":"grad_fd_meanlog <- make_fd_grad(\"meanlog\", dist_cdf) grad_fd_sdlog   <- make_fd_grad(\"sdlog\", dist_cdf)  W_fd <- make_weights_generic(   taus, q_tau,   dist_cdf, dist_pdf,   params = list(meanlog = meanlog0, sdlog = sdlog0),   grad_funcs = list(beta_meanlog = grad_fd_meanlog, beta_sdlog = grad_fd_sdlog) )  # Run GWAS with FD weights fit_fd <- param_gwas(stage1, transform = \"custom_W\", transform_args = list(W = W_fd))  cor(est[, \"beta_meanlog\"], t(fit_fd$params)[, \"beta_meanlog\"]) #> [1] 1 cor(est[, \"beta_sdlog\"],   t(fit_fd$params)[, \"beta_sdlog\"]) #> [1] 1"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Your custom functional GWAS with `make_weights_generic`","text":"make_weights_generic() enables flexible GWAS arbitrary parametric systems. provide CDF, PDF, parameter gradients (either analytic via make_fd_grad()). generalizes RIF-based GWAS models far beyond simple mean effects.","code":""},{"path":"https://michelnivard.github.io/fungwas/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michel Nivard. Author, maintainer. Fergus Hamilton. Author.","code":""},{"path":"https://michelnivard.github.io/fungwas/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Nivard M, Hamilton F (2025). fungwas: Flexible functional GWAS via RIF Quantile GWAS. R package version 0.0.1, https://michelnivard.github.io/fungwas/.","code":"@Manual{,   title = {fungwas: Flexible functional GWAS via RIF Quantile GWAS},   author = {Michel Nivard and Fergus Hamilton},   year = {2025},   note = {R package version 0.0.1},   url = {https://michelnivard.github.io/fungwas/}, }"},{"path":[]},{"path":"https://michelnivard.github.io/fungwas/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Flexible functional GWAS via RIF Quantile GWAS","text":"fungwas implements fast quantile GWAS pipeline based Recentered Influence Functions (RIFs). results quantile GWAS, might interest , enable second stage estimation SNP effects distributional parameters (e.g. means, variances, mixture components) parametric models phenotype, rather mean. Core features: RIF-based quantile GWAS closed-form OLS slopes. Delta-method based standard errors estimated parameters. Generic tau → parameter mappings via weight matrices (W). Built-weight constructors: make_weights_normal_mixture() — Construct weights two-component Normal mixture SNP effects two component means. Optionally, include effect class membership (log-odds component 1). make_weights_vqtl() — Construct weights SNP effects mean variance single Normal distribution (variance QTL analysis). make_weights_normal_mixture_vqtl() — Construct weights two-component Normal mixture vQTLs. Supports SNP effects : mixture membership (γ, log-odds component 1), component means (μ₁, μ₂), component standard deviations (σ₁, σ₂). enables testing mixture vQTLs, genetic variants can affect variability differently across mixture components. make_weights_generic() — generic gradient-based builder arbitrary parametric models. Given function returns quantiles model parameters, constructs Jacobian quantiles respect parameters (analytically via finite differences) produces appropriate weight matrix. allows study custom parametric systems log-Normal models, skew-Normals, user-defined distributions. Support fully custom W matrices, enabling user-defined parametric systems. Two-stage workflow: quantile_gwas() — run RIF-based quantile GWAS (tau-slopes). param_gwas() — map tau-slopes parameters chosen parametric model.","code":""},{"path":"https://michelnivard.github.io/fungwas/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Flexible functional GWAS via RIF Quantile GWAS","text":"","code":"# Install from GitHub # install.packages(\"devtools\") devtools::install_github(\"MichelNivard/fungwas\")"},{"path":"https://michelnivard.github.io/fungwas/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Flexible functional GWAS via RIF Quantile GWAS","text":"","code":"library(fungwas)  set.seed(42) N <- 5000; P <- 50 taus <- seq(0.10, 0.90, by = 0.05)  # Simulate genotype and phenotype maf <- runif(P, 0.05, 0.5) G <- matrix(rbinom(N * P, 2, rep(maf, each = N)), N, P) z  <- rbinom(N, 1, 0.5) Y  <- rnorm(N, mean = ifelse(z == 1, 3.0, 1.2),                sd   = ifelse(z == 1, 0.7, 0.45))  # Stage 1: tau-level GWAS stage1 <- quantile_gwas(Y, G, taus = taus)  # Stage 2: map tau slopes into mixture parameters fit <- param_gwas(   stage1,   transform = \"two_normal\",   transform_args = list(     p1 = 0.5, mu1 = 1.2, sd1 = 0.45,     mu2 = 3.0, sd2 = 0.7,     include_membership = TRUE   ),   se_mode = \"diagonal\" )  # SNP effects on mixture membership and means head(fit$params)"},{"path":"https://michelnivard.github.io/fungwas/index.html","id":"functions","dir":"","previous_headings":"","what":"Functions","title":"Flexible functional GWAS via RIF Quantile GWAS","text":"Main workflow quantile_gwas() — run RIF quantile GWAS (tau-slopes). param_gwas() — map per SNP tau-slopes user-specified parametric model parameters. Weight builders functions construct weight matrices (W) map quantile‐level SNP effects (tau‐slopes) parameters specific parametric systems. provide ready‐‐use setups common use cases: make_weights_normal_mixture() — Map tau‐slopes SNP effects means two Normal components, optional effects class membership (log‐odds belonging component 1). make_weights_vqtl() — Map tau‐slopes SNP effects mean variance single Normal distribution (variance QTL analysis). make_weights_normal_mixture_vqtl() — Map tau‐slopes SNP effects two‐component Normal mixture full flexibility: class membership (γ), component means (μ₁, μ₂), component standard deviations (σ₁, σ₂). enables mixture vQTL analysis, genetic variants influence just means also variability across mixture components. make_weights_generic() — Build weights user-defined parametric system. Requires function maps model parameters quantiles; gradients computed analytically numerically (via finite differences). Internal helpers .build_rif_matrix() — build RIF(Y; tau). .residualize_on_C() — regress SNPs outcome covariates. .nearPD_eig() — repair correlation/covariance matrices.","code":""},{"path":"https://michelnivard.github.io/fungwas/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Flexible functional GWAS via RIF Quantile GWAS","text":"MIT License © Michel Nivard & Fergus Hamilton","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_fd_grad.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a finite-difference gradient function — make_fd_grad","title":"Construct a finite-difference gradient function — make_fd_grad","text":"Builds function computes numerical gradient distribution's CDF respect single parameter using central differences.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_fd_grad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a finite-difference gradient function — make_fd_grad","text":"","code":"make_fd_grad(param, dist_cdf, eps = 1e-06)"},{"path":"https://michelnivard.github.io/fungwas/reference/make_fd_grad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a finite-difference gradient function — make_fd_grad","text":"param Name parameter (string). dist_cdf Function (y, params) -> numeric. CDF distribution. eps Finite-difference step size (default 1e-6).","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_fd_grad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a finite-difference gradient function — make_fd_grad","text":"function signature (y, params) returns dF(y; params) / d(param) given parameter.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_fd_grad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a finite-difference gradient function — make_fd_grad","text":"","code":"dist_cdf <- function(y, params) pgamma(y, shape = params$shape, scale = params$scale) grad_shape <- make_fd_grad(\"shape\", dist_cdf) grad_shape(1.5, list(shape = 2, scale = 1)) #> [1] -0.3134886"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic weight builder for parametric GWAS — make_weights_generic","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"Constructs tau--K weight matrix \\(W\\) arbitrary parametric family, mapping RIF tau-slopes \\(b(tau)\\) parameter effects.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"","code":"make_weights_generic(   taus,   q_tau,   dist_cdf,   dist_pdf,   params,   grad_funcs,   tiny = 1e-12 )"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"taus Numeric vector quantile levels (length T). q_tau Numeric vector baseline quantiles taus (length T). dist_cdf Function (y, params) -> numeric. CDF distribution. dist_pdf Function (y, params) -> numeric. PDF distribution. params Named list baseline parameters (e.g., list(mu = 0, sd = 1)). grad_funcs Named list gradient functions. element function (y, params) -> numeric giving derivative F(y; params) wrt parameter. Can analytic, constructed make_fd_grad(). tiny Small positive floor stabilize divisions (\\(f(q_tau)\\) clamped).","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"T x K numeric matrix weights columns named parameter.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"generic approach uses identity: $$W_j(tau) = - (dF/dtheta_j)(q_tau; params) / f(q_tau; params),$$ \\(F\\) CDF \\(f\\) PDF.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"","code":"taus <- seq(0.1, 0.9, 0.1) y <- rnorm(5000, 2, 1) q_tau <- as.numeric(quantile(y, taus, type = 8))  dist_cdf <- function(y, params) pnorm(y, mean = params$mu, sd = params$sd) dist_pdf <- function(y, params) dnorm(y, mean = params$mu, sd = params$sd) grad_mu  <- function(y, params) -dnorm((y - params$mu)/params$sd)/params$sd grad_sd  <- function(y, params) { z <- (y - params$mu)/params$sd; -(z*dnorm(z))/params$sd }  W <- make_weights_generic(   taus, q_tau, dist_cdf, dist_pdf,   params = list(mu = 2, sd = 1),   grad_funcs = list(beta_mu = grad_mu, beta_sd = grad_sd) )"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":null,"dir":"Reference","previous_headings":"","what":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"Constructs weight matrix \\(W\\) maps RIF tau-slopes \\(b(\\tau)\\) component-parameter effects two-Normal mixture baseline.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"","code":"make_weights_normal_mixture(   taus,   q_tau,   p1,   mu1,   sd1,   mu2,   sd2,   include_membership = FALSE,   tiny = 1e-12 )"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"taus Numeric vector quantile levels. q_tau Numeric vector baseline quantiles taus (type=8 recommended). p1 Proportion class 1 (0,1); class 2 1 - p1. mu1, sd1 Mean standard deviation component 1. mu2, sd2 Mean standard deviation component 2. include_membership Logical; include first column \"gamma\" TRUE. tiny Small positive floor stabilizing divisions (default: mixture pdf clamped tiny).","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"numeric matrix (T x K) column names: include_membership = FALSE: c(\"beta_1\",\"beta_2\") Else: c(\"gamma\",\"beta_1\",\"beta_2\")","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"Let \\(Y \\sim p_1 N(\\mu_1, \\sigma_1^2) + (1-p_1) N(\\mu_2, \\sigma_2^2)\\). baseline unconditional quantiles \\(q_\\tau\\) mixture pdf \\(f(q_\\tau)\\), default columns \\(W\\) correspond component means: $$W_1(\\tau) = \\frac{p_1 f_1(q_\\tau)}{f(q_\\tau)}, \\quad       W_2(\\tau) = \\frac{(1-p_1) f_2(q_\\tau)}{f(q_\\tau)}$$ include_membership = TRUE, first column added membership (log-odds) perturbation: $$W_\\gamma(\\tau) = - \\frac{p_1 (1-p_1)}{f(q_\\tau)}       \\left\\{F_1(q_\\tau) - F_2(q_\\tau)\\right\\}$$","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"","code":"taus <- seq(0.10, 0.90, by = 0.05) y <- rnorm(2000, 2, 1) q_tau <- as.numeric(quantile(y, taus, type = 8)) W <- make_weights_normal_mixture(   taus, q_tau,   p1 = 0.5, mu1 = 1.2, sd1 = 0.45,   mu2 = 3.0, sd2 = 0.7,   include_membership = TRUE ) dim(W); colnames(W) #> [1] 17  3 #> [1] \"gamma\"  \"beta_1\" \"beta_2\""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":null,"dir":"Reference","previous_headings":"","what":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"Constructs weight matrix W maps RIF tau-slopes \\(b(tau)\\) SNP effects parameters two-component Normal mixture: $$Y ~ p1 * N(mu1, sd1^2) + (1 - p1) * N(mu2, sd2^2).$$","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"","code":"make_weights_normal_mixture_vqtl(   taus,   q_tau,   p1,   mu1,   sd1,   mu2,   sd2,   tiny = 1e-12 )"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"taus Numeric vector quantile levels (length T). q_tau Numeric vector baseline quantiles Y taus (length T, type=8 recommended). p1 Proportion component 1 ((0,1)); component 2 proportion = 1 - p1. mu1, sd1 Mean sd component 1. mu2, sd2 Mean sd component 2. tiny Small positive floor stabilize divisions (mixture pdf clamped least tiny).","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"T x 5 numeric matrix W columns: c(\"gamma\",\"beta_mu1\",\"beta_mu2\",\"beta_sigma1\",\"beta_sigma2\").","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"Supported SNP effect targets: gamma: log-odds membership component 1 (class proportion). beta_mu1, beta_mu2: effects component means. beta_sigma1, beta_sigma2: effects component standard deviations. baseline quantiles \\(q_tau\\) mixture pdf $$f(q) = p1 f1(q) + (1 - p1) f2(q),$$ \\(f1, f2\\) component pdfs \\(F1, F2\\) CDFs, weights : Membership: $$W_gamma(tau) = - (p1 * (1 - p1) / f(q_tau)) * (F1(q_tau) - F2(q_tau))$$ Means: $$W_mu1(tau) = (p1 * f1(q_tau)) / f(q_tau), \\quad         W_mu2(tau) = ((1 - p1) * f2(q_tau)) / f(q_tau)$$ Standard deviations: $$W_sigma1(tau) = (p1 * f1(q_tau) * (q_tau - mu1) / sd1) / f(q_tau),$$ $$W_sigma2(tau) = ((1 - p1) * f2(q_tau) * (q_tau - mu2) / sd2) / f(q_tau).$$ arise derivative mixture CDF respect parameter, mapped quantile effect scale via implicit function theorem.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"","code":"taus <- seq(0.1, 0.9, 0.1) set.seed(1) y <- c(rnorm(500, 1.2, 0.6), rnorm(500, 3.0, 0.9)) q_tau <- as.numeric(quantile(y, taus, type = 8)) W <- make_weights_normal_mixture_vqtl(   taus, q_tau,   p1 = 0.5, mu1 = 1.2, sd1 = 0.6,   mu2 = 3.0, sd2 = 0.9 ) head(W) #>             gamma  beta_mu1   beta_mu2 beta_sigma1 beta_sigma2 #> tau0.1 -0.2084154 0.9635124 0.03648760  -0.7484892 -0.09187173 #> tau0.2 -0.2684789 0.9432446 0.05675541  -0.3074682 -0.12584448 #> tau0.3 -0.3559549 0.9040579 0.09594215   0.1073999 -0.18428582 #> tau0.4 -0.4982207 0.8155360 0.18446399   0.4986371 -0.29373769 #> tau0.5 -0.7001093 0.6182523 0.38174773   0.7180740 -0.46790617 #> tau0.6 -0.8293443 0.3026462 0.69735385   0.5369821 -0.56983570"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":null,"dir":"Reference","previous_headings":"","what":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"Constructs weight matrix W maps RIF tau-slopes b(tau) effects mean variance Normal baseline phenotype.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"","code":"make_weights_vqtl(taus, q_tau, mu, sd)"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"taus Numeric vector quantile levels (length T). q_tau Numeric vector baseline quantiles taus (length T, type=8 recommended). mu Baseline mean Y. sd Baseline standard deviation Y.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"T x 2 numeric matrix W columns: \"beta_mu\" effect SNP mean \"beta_sigma2\" effect SNP variance","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"Baseline: Y ~ N(mu, sigma^2). tau-quantiles q_tau = mu + sigma * z_tau, z_tau = Phi^-1(tau): $$ W_mu(tau) = 1, \\quad W_sigma2(tau) = z_tau / (2 * sigma). $$","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"","code":"taus <- seq(0.1, 0.9, by = 0.2) y <- rnorm(2000, mean = 2, sd = 1.5) q_tau <- as.numeric(quantile(y, taus, type = 8)) W <- make_weights_vqtl(taus, q_tau, mu = mean(y), sd = sd(y)) W #>        beta_mu beta_sigma2 #> tau0.1       1  -0.4126440 #> tau0.3       1  -0.1688506 #> tau0.5       1   0.0000000 #> tau0.7       1   0.1688506 #> tau0.9       1   0.4126440"},{"path":"https://michelnivard.github.io/fungwas/reference/param_gwas.html","id":null,"dir":"Reference","previous_headings":"","what":"Parametric GWAS mapping — param_gwas","title":"Parametric GWAS mapping — param_gwas","text":"Maps quantile-level GWAS results effects user-specified parametric system parameters via weight matrix W.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/param_gwas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parametric GWAS mapping — param_gwas","text":"","code":"param_gwas(   stage1,   transform = c(\"custom_W\", \"two_normal\"),   transform_args = list(),   se_mode = c(\"diagonal\", \"plugin_cor\", \"dwls\"),   plugin_R = NULL )"},{"path":"https://michelnivard.github.io/fungwas/reference/param_gwas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parametric GWAS mapping — param_gwas","text":"stage1 Output list quantile_gwas(). transform One : \"custom_W\" – supply weight matrix W transform_args. \"two_normal\" – construct weights two-component normal mixture. transform_args Arguments chosen transform. se_mode Standard error mode: \"diagonal\" – assume independence across taus (fast). \"plugin_cor\" – plugin correlation near-PD repair. \"dwls\" – diagonal weighted least squares (Q test calibrated). plugin_R Optional T x T correlation matrix \"plugin_cor\".","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/param_gwas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parametric GWAS mapping — param_gwas","text":"list following elements: W Weight matrix used parametric mapping. Mapping matrix (tau--parameter). params Estimated parameter values. SE_params Delta-method standard errors parameter estimates. Q Vector Q statistics per SNP (computed). df Degrees freedom Q statistic.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/quantile_gwas.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile-level RIF GWAS — quantile_gwas","title":"Quantile-level RIF GWAS — quantile_gwas","text":"Runs genome-wide association scan user-specified quantile levels (taus) using Recentered Influence Functions (RIF). stage estimates per-tau SNP slopes naive standard errors, independent parametric system.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/quantile_gwas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile-level RIF GWAS — quantile_gwas","text":"","code":"quantile_gwas(   Y,   G,   taus = seq(0.1, 0.9, 0.05),   C = NULL,   residualize_Y = FALSE,   density_floor = 1e-08,   benchmark = TRUE,   verbose = TRUE )"},{"path":"https://michelnivard.github.io/fungwas/reference/quantile_gwas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile-level RIF GWAS — quantile_gwas","text":"Y Numeric vector (length N), phenotype. G Numeric matrix (N x P) SNP dosages genotypes. taus Numeric vector quantile levels (default seq(0.10,0.90,0.05)). C Optional N x K covariate matrix. residualize_Y Logical; TRUE, regress Y C quantiles (SNPs C ). density_floor Positive scalar; lower bound estimated densities \\(f_Y(q_tau)\\). benchmark Logical; TRUE, include timing information. verbose Logical; print progress messages.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/quantile_gwas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile-level RIF GWAS — quantile_gwas","text":"list containing: taus – quantile levels q_tau – estimated baseline quantiles Y fhat_tau – estimated densities q_tau Q_slope – (T x P) matrix per-tau SNP slopes SE_tau – (T x P) matrix per-tau SEs timing – (benchmark=TRUE) timing breakdown","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/quantile_gwas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile-level RIF GWAS — quantile_gwas","text":"","code":"set.seed(1) N <- 2000; P <- 20 taus <- seq(0.1, 0.9, 0.1) G <- matrix(rbinom(N * P, 2, 0.3), N, P) Y <- rnorm(N) res <- quantile_gwas(Y, G, taus = taus) #> Building RIF matrix... #> Computing per-SNP tau-slopes... str(res) #> List of 6 #>  $ taus    : num [1:9] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 #>  $ q_tau   : num [1:9] -1.2777 -0.8026 -0.4494 -0.1774 0.0761 ... #>  $ fhat_tau: num [1:9] 0.17 0.254 0.33 0.375 0.409 ... #>  $ Q_slope : num [1:9, 1:20] 6.77e-02 -9.07e-03 1.39e-02 -3.07e-02 1.76e-16 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:9] \"tau0.1\" \"tau0.2\" \"tau0.3\" \"tau0.4\" ... #>   .. ..$ : NULL #>  $ SE_tau  : num [1:9, 1:20] 0.0599 0.0535 0.0471 0.0443 0.0414 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:9] \"tau0.1\" \"tau0.2\" \"tau0.3\" \"tau0.4\" ... #>   .. ..$ : NULL #>  $ timing  :List of 3 #>   ..$ rif_build_sec: num 0.003 #>   ..$ gwas_loop_sec: num 0.02 #>   ..$ total_sec    : num 0.023"}]
