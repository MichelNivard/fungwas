[{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"why-this-vignette","dir":"Articles","previous_headings":"","what":"Why this vignette?","title":"tips & ideas for GWAS in R","text":"’ve got genotypes (SNPs), covariates (age/sex/PCs), phenotype. want : Load chunk variants R without blowing memory Keep SNP metadata (ID, chr, bp, alleles) near columns Run quantile_gwas() per chunk, reuse different weight systems via param_gwas() Optionally parallelize across chunks vignette shows pragmatic routes PLINK/VCF → R → fungwas, minimal fuss.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"file-formats-and-quick-import-options","dir":"Articles","previous_headings":"","what":"File formats and quick import options","title":"tips & ideas for GWAS in R","text":"PLINK bed/bim/fam: classical; use PLINK2 slice/export easily. VCF/BCF: also fine; use seqminer::tabix.read() convert PLINK2 PGEN/RAW first. Direct R import: genio reads bed/bim/fam R objects. seqminer reads bgzipped VCF region (Tabix). bigstatsr/bigsnpr excellent large data (memory-mapped); optional. Pick one route stay consistent.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"minimal-plink2-route-recommended","dir":"Articles","previous_headings":"","what":"Minimal PLINK2 route (recommended)","title":"tips & ideas for GWAS in R","text":"Suppose chromosome 1 PLINK binary: genotype_chr1.fam, genotype_chr1.bim, genotype_chr1.bed. extract 3 Mb region (1–3,000,000 bp) plain text dosages: creates genotype_scatter_chr1_1_3000000.raw containing additive dosages (REF-coded default; change --export-allele needed). .raw columns look like: First columns: FID IID PAT MAT SEX PHENOTYPE one column per SNP, typically named like SNPID_A1 (PLINK appends counted allele) Load .raw file R: can peel IDs convert genotype columns numeric matrix: Tip: Keep SNP metadata table alongside columns (.bim index): ensures SNP info stays aligned genotype matrix columns.","code":"plink2 \\   --bfile genotype_chr1 \\   --chr 1 \\   --from-bp 1 \\   --to-bp 3000000 \\   --export A \\   --out genotype_scatter_chr1_1_3000000 library(data.table) raw <- fread(\"genotype_scatter_chr1_1_3000000.raw\") head(raw[, 1:8]) id_cols <- c(\"FID\",\"IID\",\"PAT\",\"MAT\",\"SEX\",\"PHENOTYPE\") geno_dt <- raw[, !..id_cols] G <- as.matrix(geno_dt)               # N x P  # keep SNP column names (often \"rsid_A1\") snp_cols <- colnames(geno_dt) bim <- fread(\"genotype_chr1.bim\", col.names = c(\"chr\",\"snp\",\"cm\",\"bp\",\"a1\",\"a2\")) # Restrict to region and in the same order as 'snp_cols' bim_sub <- bim[bp >= 1 & bp <= 3e6] # Match to snp_cols after PLINK’s allele suffixing # e.g., map from 'snp' + '_A1' to column names bim_sub[, plink_col := paste0(snp, \"_\", a1)] bim_sub <- bim_sub[match(snp_cols, plink_col)] stopifnot(all(bim_sub$plink_col == snp_cols))  # sanity"},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"covariates-and-pcs","dir":"Articles","previous_headings":"","what":"Covariates and PCs","title":"tips & ideas for GWAS in R","text":"FAM: get IID, SEX, placeholder phenotype. PCs: read separate file merge IID. Ensure row order G, covariates C, phenotype Y identical.","code":"fam <- fread(\"genotype_chr1.fam\", col.names = c(\"FID\",\"IID\",\"PAT\",\"MAT\",\"SEX\",\"PHENO\")) pcs <- fread(\"pcs.tsv\")   # columns: IID, PC1..PC20 covs <- merge(fam[, .(IID, SEX)], pcs, by = \"IID\", all.x = TRUE)  # Reorder covs to match the .raw row order (IID in 'raw') covs <- covs[match(raw$IID, covs$IID)] stopifnot(all(covs$IID == raw$IID))  # Build C matrix: intercept is handled internally, so do not include it here C <- as.matrix(covs[, .(SEX, PC1, PC2, PC3, PC4, PC5)])"},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"chunking-strategy","dir":"Articles","previous_headings":"","what":"Chunking strategy","title":"tips & ideas for GWAS in R","text":"Don’t try load SNPs across chromosomes . Pick chunking unit: region (e.g. 3–10 Mb windows) SNP count (e.g. 25k–100k SNPs per chunk) Heuristics: Consider bigsnpr memory-mapped matrices extremely large. Time scales O(N × P × |taus|) inside quantile_gwas(). practical starting point: N 200k, P ≈ 10k–50k per chunk, |taus| ≈ 15–25. Parallelize across chunks (within) keep code simple.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"a-sketch-of-an-end-to-end-example-one-chunk","dir":"Articles","previous_headings":"","what":"A sketch of an end-to-end example (one chunk)","title":"tips & ideas for GWAS in R","text":"Assume ’ve loaded one region G, plus Y C. two stages? can reuse stage1 test multiple parametric systems (e.g., vQTL, mixture, log-normal) without re-running heavy SNP × τ loop.","code":"# 1) Choose quantiles and run Stage 1 once per chunk taus  <- seq(0.10, 0.90, by = 0.05) stage1 <- quantile_gwas(   Y, G,   taus = taus,   C = C,   residualize_Y = FALSE,   # default: only SNPs are residualized on C   benchmark = TRUE )  # 2a) Map to mean/variance (vQTL) W_var <- make_weights_vqtl(taus, stage1$q_tau, mu = mean(Y), sd = sd(Y)) fit_var <- param_gwas(stage1, transform = \"custom_W\", transform_args = list(W = W_var),                       se_mode = \"plugin_cor\")  # 2b) Map to two-component mixture (means + membership) fit_mix <- param_gwas(   stage1,   transform = \"two_normal\",   transform_args = list(     p1 = 0.5, mu1 = 1.2, sd1 = 0.45,     mu2 = 3.0, sd2 = 0.7,     include_membership = TRUE   ),   se_mode = \"diagonal\" )  # 3) Keep SNP info alongside results est_var <- data.table(bim_sub[, .(chr, snp, bp, a1, a2)], t(fit_var$params)) est_mix <- data.table(bim_sub[, .(chr, snp, bp, a1, a2)], t(fit_mix$params))  # Example preview head(est_var) head(est_mix)"},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"parallelism-across-chunks","dir":"Articles","previous_headings":"","what":"Parallelism across chunks","title":"tips & ideas for GWAS in R","text":"simplest approach: split genome chunks (region SNP count), run chunk separate process. two lightweight options.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"option-a-future-apply","dir":"Articles","previous_headings":"Parallelism across chunks","what":"Option A: future.apply","title":"tips & ideas for GWAS in R","text":"","code":"library(future.apply) plan(multisession, workers = 4)  # or multicore on Linux  chunk_specs <- data.table(   chr = 1,   from_bp = seq(1, 2.5e8, by = 5e6),   to_bp   = pmin(seq(5e6, 2.5e8 + 5e6, by = 5e6), 2.5e8) )  run_chunk <- function(chr, from_bp, to_bp) {   # 1) Use plink2 to export .raw for the region (system call)   outpref <- sprintf(\"chr%s_%d_%d\", chr, from_bp, to_bp)   cmd <- sprintf(\"plink2 --bfile genotype_chr%s --chr %s --from-bp %d --to-bp %d --export A --out %s\",                  chr, chr, from_bp, to_bp, outpref)   system(cmd)    # 2) Read .raw, .bim subset; build G and SNP meta   raw  <- fread(paste0(outpref, \".raw\"))   fam  <- fread(paste0(\"genotype_chr\", chr, \".fam\"),                 col.names = c(\"FID\",\"IID\",\"PAT\",\"MAT\",\"SEX\",\"PHENO\"))   bim  <- fread(paste0(\"genotype_chr\", chr, \".bim\"),                 col.names = c(\"chr\",\"snp\",\"cm\",\"bp\",\"a1\",\"a2\"))    # region meta   meta <- bim[bp >= from_bp & bp <= to_bp]    # genotype matrix   id_cols <- c(\"FID\",\"IID\",\"PAT\",\"MAT\",\"SEX\",\"PHENOTYPE\")   geno_dt <- raw[, !..id_cols]   G <- as.matrix(geno_dt)   snp_cols <- colnames(geno_dt)    # align meta to columns (assuming PLINK col names as snp_a1)   meta[, plink_col := paste0(snp, \"_\", a1)]   meta <- meta[match(snp_cols, plink_col)]   stopifnot(all(meta$plink_col == snp_cols))    # 3) Merge PCs/covariates and phenotype in the same row order as 'raw'   pcs  <- fread(\"pcs.tsv\")    # has IID, PC1..PC20   covs <- merge(fam[, .(IID, SEX)], pcs, by = \"IID\", all.x = TRUE)   covs <- covs[match(raw$IID, covs$IID)]   C <- as.matrix(covs[, .(SEX, PC1, PC2, PC3, PC4, PC5)])    # 4) Pull phenotype Y in the same order; replace with your source   pheno <- fread(\"pheno.tsv\") # IID, Y   pheno <- pheno[match(raw$IID, pheno$IID)]   Y <- pheno$Y    # 5) Quantile GWAS and one mapping (you can add more)   taus   <- seq(0.10, 0.90, 0.05)   stage1 <- quantile_gwas(Y, G, taus = taus, C = C, benchmark = FALSE)    W_var  <- make_weights_vqtl(taus, stage1$q_tau, mu = mean(Y), sd = sd(Y))   fit    <- param_gwas(stage1, transform = \"custom_W\", transform_args = list(W = W_var))    # 6) Return a data.table with meta + estimates   out <- data.table(meta[, .(chr, snp, bp, a1, a2)], t(fit$params))   out[] }  results_list <- future_mapply(   run_chunk,   chr = chunk_specs$chr,   from_bp = chunk_specs$from_bp,   to_bp = chunk_specs$to_bp,   SIMPLIFY = FALSE )  results <- rbindlist(results_list, use.names = TRUE, fill = TRUE) fwrite(results, \"fungwas_vqtl_results.tsv\")"},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"option-b-foreach-doparallel","dir":"Articles","previous_headings":"Parallelism across chunks","what":"Option B: foreach + doParallel","title":"tips & ideas for GWAS in R","text":"Works similarly; pick whichever cluster policy prefers.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"vcf-input-alternative-no-plink2","dir":"Articles","previous_headings":"","what":"VCF input alternative (no PLINK2)","title":"tips & ideas for GWAS in R","text":"bgzipped VCF/BCF Tabix index, can slice regions directly: route great already distribute data indexed VCF per chromosome.","code":"library(seqminer)  region <- \"1:1-3000000\" vcf_file <- \"chr1.vcf.bgz\"  # dosage extraction (depends on FORMAT fields and your VCF) geno <- seqminer::tabix.read(vcf_file, region) # Convert to an N x P dosage matrix 'G' for your samples # Build SNP meta from INFO/ID/POS/REF/ALT in 'geno'"},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"practical-notes","dir":"Articles","previous_headings":"","what":"Practical notes","title":"tips & ideas for GWAS in R","text":"Allele coding: PLINK2 --export counts REF allele default. prefer effect allele ALT, set --export-allele accordingly, keep consistent interpreting signs. Sample order: Always reorder covariates phenotype match genotype rows. QC: vignette assumes ’ve already done SNP/sample QC (missingness, MAF, HWE, ancestry, duplicates). Chunk size: Aim total memory ( ) 2–8 GB per worker safe; test one chunk scale. Stage reuse: Save stage1 objects per chunk (e.g. saveRDS(stage1, \"chunkX_stage1.rds\")) can rerun different param_gwas() analyses later without repeating Stage 1.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"interpreting-results","dir":"Articles","previous_headings":"","what":"Interpreting results","title":"tips & ideas for GWAS in R","text":"quantile_gwas() returns τ-slope matrices (Q_slope, SE_tau) baseline quantiles/densities. param_gwas() returns per-SNP effects chosen parameters delta-method SEs: vQTL: beta_mu, beta_sigma2 Mixture: gamma (membership), beta_1, beta_2 (component means) Mixture vQTL: add beta_sigma1, beta_sigma2 Keep joined table [SNP meta | parameter estimates | SEs] clean downstream work.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/GWAS-in-R.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"tips & ideas for GWAS in R","text":"Use PLINK2 (Tabix/VCF) export chunked genotype matrices. Keep SNP metadata aligned columns. Run Stage 1 per chunk; reuse multiple parameter systems. Parallelize across chunks; keep worker’s memory footprint modest. Store results SNP meta painless interpretation plotting.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Functional GWAS via Quantile Regression and RIF","text":"GWAS focus mean effects: SNP increase decrease average level trait? genetic effects can subtle: SNPs may increase variability (vQTLs). Others may shift balance subtypes mixture components. may affect mean variance together. fungwas package provides fast, flexible framework test SNP effects distributional parameters, just means.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"core-idea","dir":"Articles","previous_headings":"","what":"Core idea","title":"Functional GWAS via Quantile Regression and RIF","text":"Use Recentered Influence Functions (RIFs) link SNPs changes trait quantiles. gives “SNP slopes” across distribution. fast (closed-form OLS, iterative quantile regression). Combine quantile slopes using weight matrix W map parameter interest: mean, variance, mixture membership, etc. Estimate SNP effects standard errors parameters. two-step process backbone fungwas.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"example-1-standard-mean-effect","dir":"Articles","previous_headings":"","what":"Example 1: Standard mean effect","title":"Functional GWAS via Quantile Regression and RIF","text":"Let’s simulate simple trait SNP effects mean. , column beta_mu corresponds SNP effect mean.","code":"N <- 5000 P <- 50 maf <- runif(P, 0.05, 0.5) G <- matrix(rbinom(N * P, 2, rep(maf, each = N)), N, P) colnames(G) <- paste0(\"SNP\", seq_len(P))  # Simulate a mean effect beta_true <- rnorm(P) / 40 Y <- rnorm(N, mean = 2 + G %*% beta_true, sd = 1)  taus <- seq(0.1, 0.9, 0.05)  # Stage 1: quantile GWAS stage1 <- quantile_gwas(Y, G, taus = taus) #> Building RIF matrix... #> Computing per-SNP tau-slopes...  # Stage 2: mean/variance mapping (vQTL weights) W <- make_weights_vqtl(taus, stage1$q_tau, mu = mean(Y), sd = sd(Y)) fit <- param_gwas(stage1, transform = \"custom_W\", transform_args = list(W = W))  head(t(fit$params)) #>          beta_mu  beta_sigma2 #> SNP1 -0.03798818 -0.026820633 #> SNP2 -0.01832948  0.018785274 #> SNP3  0.02361505 -0.045563528 #> SNP4  0.04302755  0.001305224 #> SNP5  0.05758468 -0.048737974 #> SNP6  0.01513990  0.199157417"},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"example-2-variance-effects-vqtls","dir":"Articles","previous_headings":"","what":"Example 2: Variance effects (vQTLs)","title":"Functional GWAS via Quantile Regression and RIF","text":"Suppose SNPs affect just mean also spread phenotype. Now obtain SNP effects mean variance.","code":"beta_mu_true     <- rnorm(P) / 40 beta_sigma2_true <- rnorm(P) / 40  mu <- 2 + G %*% beta_mu_true sigma2 <- 1 + G %*% beta_sigma2_true sigma2[sigma2 <= 0] <- 0.1  Y <- rnorm(N, mean = mu, sd = sqrt(sigma2))  taus <- seq(0.05, 0.95, 0.05) stage1 <- quantile_gwas(Y, G, taus = taus) #> Building RIF matrix... #> Computing per-SNP tau-slopes...  W_var <- make_weights_vqtl(taus, stage1$q_tau, mu = mean(Y), sd = sd(Y)) fit_var <- param_gwas(stage1, transform = \"custom_W\", transform_args = list(W = W_var))  head(t(fit_var$params)) #>          beta_mu beta_sigma2 #> SNP1 -0.01474599 -0.10471233 #> SNP2  0.03817296  0.02671172 #> SNP3 -0.06506831 -0.05781526 #> SNP4  0.01184463  0.03804201 #> SNP5 -0.01047337 -0.04669658 #> SNP6  0.01771871 -0.08678875"},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"example-3-mixture-gwas","dir":"Articles","previous_headings":"","what":"Example 3: Mixture GWAS","title":"Functional GWAS via Quantile Regression and RIF","text":"Many complex traits mixtures underlying subtypes. example, “cases” might consist two symptom clusters, biomarker distributions may show multimodality. can model SNP effects component means class membership two-Normal mixture.","code":"p1 <- 0.5 mu1 <- 1.2; sd1 <- 0.5 mu2 <- 3.0; sd2 <- 0.8  # Simulate phenotype z <- rbinom(N, 1, p1) Y <- ifelse(z == 1, rnorm(N, mu1, sd1), rnorm(N, mu2, sd2))  taus <- seq(0.1, 0.9, 0.05) stage1 <- quantile_gwas(Y, G, taus = taus) #> Building RIF matrix... #> Computing per-SNP tau-slopes...  fit_mix <- param_gwas(   stage1,   transform = \"two_normal\",   transform_args = list(     p1 = p1, mu1 = mu1, sd1 = sd1,     mu2 = mu2, sd2 = sd2,     include_membership = TRUE   ) )  head(t(fit_mix$params)) #>            gamma        beta_1        beta_2 #> SNP1 -0.05727378 -1.903029e-02 -0.0233213774 #> SNP2  0.07954904 -7.991301e-05  0.0076335131 #> SNP3 -0.06057390 -2.434824e-02  0.0003425944 #> SNP4  0.02074416 -7.745207e-04 -0.0188630721 #> SNP5 -0.12819602 -1.526194e-02 -0.0227835128 #> SNP6  0.11976032  8.322496e-02 -0.0342396586"},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"key-functions-and-workflow","dir":"Articles","previous_headings":"","what":"Key functions and workflow","title":"Functional GWAS via Quantile Regression and RIF","text":"workflow fungwas always follows two stages: Function: quantile_gwas() Y: vector phenotypes (length N). G: genotype matrix, N × P (rows = individuals, cols = SNPs). C: optional covariates (N × K, e.g. age, sex, PCs). taus: grid quantile levels (e.g. seq(0.1, 0.9, 0.05)). list containing RIF slopes per SNP × τ, SEs, baseline quantiles. Think quantile-level GWAS. Function: param_gwas() output quantile_gwas(). mapping (W) tells software combine τ-slopes parameter effects. Either supply custom W use pre-built weight constructor. SNP effects parameters (means, variances, mixture membership, etc). interpretation stage, translating distributional shifts biologically meaningful parameters.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"weight-builders","dir":"Articles","previous_headings":"Key functions and workflow","what":"Weight builders","title":"Functional GWAS via Quantile Regression and RIF","text":"Weight matrices (W) define quantile slopes correspond parameter changes.fungwas provides several ready-made constructors: make_weights_vqtl() — use want SNP effects mean variance Normal trait. Example: height variability, BMI dispersion. Component means. (Optionally) class membership probability. Example: SNPs shifting balance subtypes cases/controls. make_weights_mixture_vqtl() — extended version SNPs can also affect component variances (addition means membership). Example: genetic effects subtype prevalence within-subtype variability. provide distribution’s CDF, PDF, derivatives wrt parameters. use finite-difference helpers (make_fd_grad()). Example: log-normal GWAS meanlog sdlog. Use phenotype better described non-standard distribution.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"putting-it-together-a-typical-workflow","dir":"Articles","previous_headings":"Key functions and workflow","what":"Putting it together: a typical workflow","title":"Functional GWAS via Quantile Regression and RIF","text":"Prepare inputs: Phenotype vector Y. Genotype dosage matrix G (SNPs already QC’d). Optional covariate matrix C (e.g. sex, age, ancestry PCs). Run quantile GWAS: Choose weight system: mean & variance: two-component mixture: custom: Map parameters: Inspect results: practice: Stage 1 (quantile_gwas) run per dataset. can re-use different weight systems (param_gwas) test multiple hypotheses (means, variances, mixtures, etc) without rerunning GWAS.","code":"taus <- seq(0.1, 0.9, 0.05) stage1 <- quantile_gwas(Y, G, taus = taus, C = covariates) W <- make_weights_vqtl(taus, stage1$q_tau, mu = mean(Y), sd = sd(Y)) W <- make_weights_normal_mixture(taus, stage1$q_tau,                                  p1 = 0.5, mu1 = 1, sd1 = 1,                                  mu2 = 3, sd2 = 1.5,                                  include_membership = TRUE) W <- make_weights_generic(taus, stage1$q_tau, dist_cdf, dist_pdf, params, grad_funcs) fit <- param_gwas(stage1, transform = \"custom_W\", transform_args = list(W = W)) head(t(fit$params))   # SNP effects on chosen parameters head(t(fit$SE_params)) # Standard errors"},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"why-use-fungwas","dir":"Articles","previous_headings":"","what":"Why use fungwas?","title":"Functional GWAS via Quantile Regression and RIF","text":"Go beyond mean effects: test variance, mixtures, heterogeneity. Fast: closed-form OLS, heavy quantile regression. Flexible: distributional system can defined via make_weights_generic. Useful vQTL discovery, subtype genetics, causal inference mean effects don’t tell full story.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"Further reading","title":"Functional GWAS via Quantile Regression and RIF","text":"Koenker & Bassett (1978), Quantile Regression. Firpo, Fortin, & Lemieux (2009), Influence Function Regression. Recent applications vQTL mixture genetics GWAS.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/fungwas-overview.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Functional GWAS via Quantile Regression and RIF","text":"fungwas allows re-think GWAS: instead asking “SNP affect mean?”, can ask “SNP affect distribution?” — variance, mixtures, user-defined systems.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Your custom functional GWAS with `make_weights_generic`","text":"fungwas, core idea map quantile GWAS slopes parameters parametric system (means, variances, mixture components, etc). mapping accomplished weight matrices W. specific constructors built-(e.g. make_weights_normal_mixture, make_weights_vqtl), function make_weights_generic() allows define mapping distribution long can supply: CDF PDF distribution. gradients CDF wrt parameters (analytic finite-difference). vignette illustrates use log-normal phenotype.","code":""},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"example-log-normal-gwas","dir":"Articles","previous_headings":"","what":"Example: Log-Normal GWAS","title":"Your custom functional GWAS with `make_weights_generic`","text":"simulate phenotypes log-normal distribution SNP effects meanlog sdlog parameters.","code":"# Simulate genotypes N <- 5000 P <- 50 maf <- runif(P, 0.05, 0.5) G <- matrix(rbinom(N * P, 2, rep(maf, each = N)), nrow = N, ncol = P) colnames(G) <- paste0(\"SNP\", seq_len(P))  # True SNP effects beta_meanlog_true <- rnorm(P) / 40 beta_sdlog_true   <- rnorm(P) / 40  # Baseline parameters meanlog0 <- 0.5 sdlog0   <- 0.7  # Individual parameters meanlog <- meanlog0 + G %*% beta_meanlog_true sdlog   <- pmax(sdlog0 + G %*% beta_sdlog_true, 0.1)  # Phenotype Y <- rlnorm(N, meanlog = meanlog, sdlog = sdlog)"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"step-1-define-distribution-and-gradients","dir":"Articles","previous_headings":"","what":"Step 1: Define distribution and gradients","title":"Your custom functional GWAS with `make_weights_generic`","text":"define CDF PDF log-normal, supply gradients CDF wrt meanlog sdlog. derivatives determine SNP effects parameters expressed quantile space.","code":"dist_cdf <- function(y, params) plnorm(y, meanlog = params$meanlog, sdlog = params$sdlog) dist_pdf <- function(y, params) dlnorm(y, meanlog = params$meanlog, sdlog = params$sdlog)  grad_meanlog <- function(y, params) {   z <- (log(y) - params$meanlog) / params$sdlog   -dnorm(z) / params$sdlog } grad_sdlog <- function(y, params) {   z <- (log(y) - params$meanlog) / params$sdlog   -(z * dnorm(z)) / params$sdlog }"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"step-2-build-weights","dir":"Articles","previous_headings":"","what":"Step 2: Build weights","title":"Your custom functional GWAS with `make_weights_generic`","text":"compute weights grid quantiles. column W corresponds mapping quantile slopes parameter-space effects.","code":"taus <- seq(0.1, 0.9, 0.05) q_tau <- as.numeric(quantile(Y, taus, type = 8))  W <- make_weights_generic(   taus, q_tau,   dist_cdf, dist_pdf,   params = list(meanlog = meanlog0, sdlog = sdlog0),   grad_funcs = list(beta_meanlog = grad_meanlog, beta_sdlog = grad_sdlog) )  head(W) #>         beta_meanlog beta_sdlog #> tau0.1     0.8193355 -0.8184712 #> tau0.15    0.9722950 -0.7335216 #> tau0.2     1.1053469 -0.6313754 #> tau0.25    1.2319771 -0.5128188 #> tau0.3     1.3678373 -0.3649568 #> tau0.35    1.4923085 -0.2124957"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"step-3-run-two-stage-gwas","dir":"Articles","previous_headings":"","what":"Step 3: Run two-stage GWAS","title":"Your custom functional GWAS with `make_weights_generic`","text":"First, run quantile GWAS estimate SNP effects quantile (RIF slopes). , map parameter-space using param_gwas() custom W.","code":"stage1 <- quantile_gwas(Y, G, taus = taus, benchmark = FALSE) #> Building RIF matrix... #> Computing per-SNP tau-slopes...  fit <- param_gwas(   stage1,   transform = \"custom_W\",   transform_args = list(W = W),   se_mode = \"diagonal\" )  head(t(fit$params)) #>      beta_meanlog  beta_sdlog #> SNP1 -0.069766804  0.03844083 #> SNP2  0.017892104 -0.01579062 #> SNP3 -0.009028385  0.02589287 #> SNP4  0.021612584 -0.02085744 #> SNP5  0.045506929 -0.01453348 #> SNP6  0.013347512 -0.03759752"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"step-4-compare-to-true-effects","dir":"Articles","previous_headings":"","what":"Step 4: Compare to true effects","title":"Your custom functional GWAS with `make_weights_generic`","text":"can check recovery correlating estimated effects truth.","code":"est <- t(fit$params)  cor_meanlog <- cor(beta_meanlog_true, est[, \"beta_meanlog\"]) cor_sdlog   <- cor(beta_sdlog_true,   est[, \"beta_sdlog\"])  cor_meanlog #> [1] 0.8096836 cor_sdlog #> [1] 0.8384027"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"finite-difference-gradients","dir":"Articles","previous_headings":"","what":"Finite-Difference Gradients","title":"Your custom functional GWAS with `make_weights_generic`","text":"Instead hand-coding gradients, can generate automatically using make_fd_grad(). Analytic FD versions give nearly identical results, making FD convenient option analytic gradients complicated.","code":"grad_fd_meanlog <- make_fd_grad(\"meanlog\", dist_cdf) grad_fd_sdlog   <- make_fd_grad(\"sdlog\", dist_cdf)  W_fd <- make_weights_generic(   taus, q_tau,   dist_cdf, dist_pdf,   params = list(meanlog = meanlog0, sdlog = sdlog0),   grad_funcs = list(beta_meanlog = grad_fd_meanlog, beta_sdlog = grad_fd_sdlog) )  # Run GWAS with FD weights fit_fd <- param_gwas(stage1, transform = \"custom_W\", transform_args = list(W = W_fd))  cor(est[, \"beta_meanlog\"], t(fit_fd$params)[, \"beta_meanlog\"]) #> [1] 1 cor(est[, \"beta_sdlog\"],   t(fit_fd$params)[, \"beta_sdlog\"]) #> [1] 1"},{"path":"https://michelnivard.github.io/fungwas/articles/weight-building.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Your custom functional GWAS with `make_weights_generic`","text":"make_weights_generic() enables flexible GWAS arbitrary parametric systems. provide CDF, PDF, parameter gradients (either analytic via make_fd_grad()). generalizes RIF-based GWAS models far beyond simple mean effects.","code":""},{"path":"https://michelnivard.github.io/fungwas/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michel Nivard. Author, maintainer. Fergus Hamilton. Author.","code":""},{"path":"https://michelnivard.github.io/fungwas/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Nivard M, Hamilton F (2025). fungwas: Flexible functional GWAS via RIF Quantile GWAS. R package version 0.0.1, https://michelnivard.github.io/fungwas/.","code":"@Manual{,   title = {fungwas: Flexible functional GWAS via RIF Quantile GWAS},   author = {Michel Nivard and Fergus Hamilton},   year = {2025},   note = {R package version 0.0.1},   url = {https://michelnivard.github.io/fungwas/}, }"},{"path":[]},{"path":"https://michelnivard.github.io/fungwas/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Flexible functional GWAS via RIF Quantile GWAS","text":"fungwas implements fast quantile GWAS pipeline based Recentered Influence Functions (RIFs). results quantile GWAS, might interest , enable second stage estimation SNP effects distributional parameters (e.g. means, variances, mixture components) parametric models phenotype, rather mean. Core features: RIF-based quantile GWAS closed-form OLS slopes. Delta-method based standard errors estimated parameters. Generic tau → parameter mappings via weight matrices (W). Built-weight constructors: make_weights_normal_mixture() — Construct weights two-component Normal mixture SNP effects two component means. Optionally, include effect class membership (log-odds component 1). make_weights_vqtl() — Construct weights SNP effects mean variance single Normal distribution (variance QTL analysis). make_weights_normal_mixture_vqtl() — Construct weights two-component Normal mixture vQTLs. Supports SNP effects : mixture membership (γ, log-odds component 1), component means (μ₁, μ₂), component standard deviations (σ₁, σ₂). enables testing mixture vQTLs, genetic variants can affect variability differently across mixture components. make_weights_generic() — generic gradient-based builder arbitrary parametric models. Given function returns quantiles model parameters, constructs Jacobian quantiles respect parameters (analytically via finite differences) produces appropriate weight matrix. allows study custom parametric systems log-Normal models, skew-Normals, user-defined distributions. Support fully custom W matrices, enabling user-defined parametric systems. Two-stage workflow: quantile_gwas() — run RIF-based quantile GWAS (tau-slopes). param_gwas() — map tau-slopes parameters chosen parametric model.","code":""},{"path":"https://michelnivard.github.io/fungwas/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Flexible functional GWAS via RIF Quantile GWAS","text":"","code":"# Install from GitHub # install.packages(\"devtools\") devtools::install_github(\"MichelNivard/fungwas\")"},{"path":"https://michelnivard.github.io/fungwas/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Flexible functional GWAS via RIF Quantile GWAS","text":"","code":"library(fungwas)  set.seed(42) N <- 5000; P <- 50 taus <- seq(0.10, 0.90, by = 0.05)  # Simulate genotype and phenotype maf <- runif(P, 0.05, 0.5) G <- matrix(rbinom(N * P, 2, rep(maf, each = N)), N, P) z  <- rbinom(N, 1, 0.5) Y  <- rnorm(N, mean = ifelse(z == 1, 3.0, 1.2),                sd   = ifelse(z == 1, 0.7, 0.45))  # Stage 1: tau-level GWAS stage1 <- quantile_gwas(Y, G, taus = taus)  # Stage 2: map tau slopes into mixture parameters fit <- param_gwas(   stage1,   transform = \"two_normal\",   transform_args = list(     p1 = 0.5, mu1 = 1.2, sd1 = 0.45,     mu2 = 3.0, sd2 = 0.7,     include_membership = TRUE   ),   se_mode = \"diagonal\" )  # SNP effects on mixture membership and means head(fit$params)"},{"path":"https://michelnivard.github.io/fungwas/index.html","id":"functions","dir":"","previous_headings":"","what":"Functions","title":"Flexible functional GWAS via RIF Quantile GWAS","text":"Main workflow quantile_gwas() — run RIF quantile GWAS (tau-slopes). param_gwas() — map per SNP tau-slopes user-specified parametric model parameters. Weight builders functions construct weight matrices (W) map quantile‐level SNP effects (tau‐slopes) parameters specific parametric systems. provide ready‐‐use setups common use cases: make_weights_normal_mixture() — Map tau‐slopes SNP effects means two Normal components, optional effects class membership (log‐odds belonging component 1). make_weights_vqtl() — Map tau‐slopes SNP effects mean variance single Normal distribution (variance QTL analysis). make_weights_normal_mixture_vqtl() — Map tau‐slopes SNP effects two‐component Normal mixture full flexibility: class membership (γ), component means (μ₁, μ₂), component standard deviations (σ₁, σ₂). enables mixture vQTL analysis, genetic variants influence just means also variability across mixture components. make_weights_generic() — Build weights user-defined parametric system. Requires function maps model parameters quantiles; gradients computed analytically numerically (via finite differences). Internal helpers .build_rif_matrix() — build RIF(Y; tau). .residualize_on_C() — regress SNPs outcome covariates. .nearPD_eig() — repair correlation/covariance matrices.","code":""},{"path":"https://michelnivard.github.io/fungwas/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Flexible functional GWAS via RIF Quantile GWAS","text":"MIT License © Michel Nivard & Fergus Hamilton","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_fd_grad.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a finite-difference gradient function — make_fd_grad","title":"Construct a finite-difference gradient function — make_fd_grad","text":"Builds function computes numerical gradient distribution's CDF respect single parameter using central differences.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_fd_grad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a finite-difference gradient function — make_fd_grad","text":"","code":"make_fd_grad(param, dist_cdf, eps = 1e-06)"},{"path":"https://michelnivard.github.io/fungwas/reference/make_fd_grad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a finite-difference gradient function — make_fd_grad","text":"param Name parameter (string). dist_cdf Function (y, params) -> numeric. CDF distribution. eps Finite-difference step size (default 1e-6).","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_fd_grad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a finite-difference gradient function — make_fd_grad","text":"function signature (y, params) returns dF(y; params) / d(param) given parameter.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_fd_grad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a finite-difference gradient function — make_fd_grad","text":"","code":"dist_cdf <- function(y, params) pgamma(y, shape = params$shape, scale = params$scale) grad_shape <- make_fd_grad(\"shape\", dist_cdf) grad_shape(1.5, list(shape = 2, scale = 1)) #> [1] -0.3134886"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic weight builder for parametric GWAS — make_weights_generic","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"Constructs tau--K weight matrix \\(W\\) arbitrary parametric family, mapping RIF tau-slopes \\(b(tau)\\) parameter effects.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"","code":"make_weights_generic(   taus,   q_tau,   dist_cdf,   dist_pdf,   params,   grad_funcs,   tiny = 1e-12 )"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"taus Numeric vector quantile levels (length T). q_tau Numeric vector baseline quantiles taus (length T). dist_cdf Function (y, params) -> numeric. CDF distribution. dist_pdf Function (y, params) -> numeric. PDF distribution. params Named list baseline parameters (e.g., list(mu = 0, sd = 1)). grad_funcs Named list gradient functions. element function (y, params) -> numeric giving derivative F(y; params) wrt parameter. Can analytic, constructed make_fd_grad(). tiny Small positive floor stabilize divisions (\\(f(q_tau)\\) clamped).","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"T x K numeric matrix weights columns named parameter.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"generic approach uses identity: $$W_j(tau) = - (dF/dtheta_j)(q_tau; params) / f(q_tau; params),$$ \\(F\\) CDF \\(f\\) PDF.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_generic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic weight builder for parametric GWAS — make_weights_generic","text":"","code":"taus <- seq(0.1, 0.9, 0.1) y <- rnorm(5000, 2, 1) q_tau <- as.numeric(quantile(y, taus, type = 8))  dist_cdf <- function(y, params) pnorm(y, mean = params$mu, sd = params$sd) dist_pdf <- function(y, params) dnorm(y, mean = params$mu, sd = params$sd) grad_mu  <- function(y, params) -dnorm((y - params$mu)/params$sd)/params$sd grad_sd  <- function(y, params) { z <- (y - params$mu)/params$sd; -(z*dnorm(z))/params$sd }  W <- make_weights_generic(   taus, q_tau, dist_cdf, dist_pdf,   params = list(mu = 2, sd = 1),   grad_funcs = list(beta_mu = grad_mu, beta_sd = grad_sd) )"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":null,"dir":"Reference","previous_headings":"","what":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"Constructs weight matrix \\(W\\) maps RIF tau-slopes \\(b(\\tau)\\) component-parameter effects two-Normal mixture baseline.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"","code":"make_weights_normal_mixture(   taus,   q_tau,   p1,   mu1,   sd1,   mu2,   sd2,   include_membership = FALSE,   tiny = 1e-12 )"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"taus Numeric vector quantile levels. q_tau Numeric vector baseline quantiles taus (type=8 recommended). p1 Proportion class 1 (0,1); class 2 1 - p1. mu1, sd1 Mean standard deviation component 1. mu2, sd2 Mean standard deviation component 2. include_membership Logical; include first column \"gamma\" TRUE. tiny Small positive floor stabilizing divisions (default: mixture pdf clamped tiny).","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"numeric matrix (T x K) column names: include_membership = FALSE: c(\"beta_1\",\"beta_2\") Else: c(\"gamma\",\"beta_1\",\"beta_2\")","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"Let \\(Y \\sim p_1 N(\\mu_1, \\sigma_1^2) + (1-p_1) N(\\mu_2, \\sigma_2^2)\\). baseline unconditional quantiles \\(q_\\tau\\) mixture pdf \\(f(q_\\tau)\\), default columns \\(W\\) correspond component means: $$W_1(\\tau) = \\frac{p_1 f_1(q_\\tau)}{f(q_\\tau)}, \\quad       W_2(\\tau) = \\frac{(1-p_1) f_2(q_\\tau)}{f(q_\\tau)}$$ include_membership = TRUE, first column added membership (log-odds) perturbation: $$W_\\gamma(\\tau) = - \\frac{p_1 (1-p_1)}{f(q_\\tau)}       \\left\\{F_1(q_\\tau) - F_2(q_\\tau)\\right\\}$$","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build tau-by-K weights for a 2-component Normal mixture — make_weights_normal_mixture","text":"","code":"taus <- seq(0.10, 0.90, by = 0.05) y <- rnorm(2000, 2, 1) q_tau <- as.numeric(quantile(y, taus, type = 8)) W <- make_weights_normal_mixture(   taus, q_tau,   p1 = 0.5, mu1 = 1.2, sd1 = 0.45,   mu2 = 3.0, sd2 = 0.7,   include_membership = TRUE ) dim(W); colnames(W) #> [1] 17  3 #> [1] \"gamma\"  \"beta_1\" \"beta_2\""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":null,"dir":"Reference","previous_headings":"","what":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"Constructs weight matrix W maps RIF tau-slopes \\(b(tau)\\) SNP effects parameters two-component Normal mixture: $$Y ~ p1 * N(mu1, sd1^2) + (1 - p1) * N(mu2, sd2^2).$$","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"","code":"make_weights_normal_mixture_vqtl(   taus,   q_tau,   p1,   mu1,   sd1,   mu2,   sd2,   tiny = 1e-12 )"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"taus Numeric vector quantile levels (length T). q_tau Numeric vector baseline quantiles Y taus (length T, type=8 recommended). p1 Proportion component 1 ((0,1)); component 2 proportion = 1 - p1. mu1, sd1 Mean sd component 1. mu2, sd2 Mean sd component 2. tiny Small positive floor stabilize divisions (mixture pdf clamped least tiny).","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"T x 5 numeric matrix W columns: c(\"gamma\",\"beta_mu1\",\"beta_mu2\",\"beta_sigma1\",\"beta_sigma2\").","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"Supported SNP effect targets: gamma: log-odds membership component 1 (class proportion). beta_mu1, beta_mu2: effects component means. beta_sigma1, beta_sigma2: effects component standard deviations. baseline quantiles \\(q_tau\\) mixture pdf $$f(q) = p1 f1(q) + (1 - p1) f2(q),$$ \\(f1, f2\\) component pdfs \\(F1, F2\\) CDFs, weights : Membership: $$W_gamma(tau) = - (p1 * (1 - p1) / f(q_tau)) * (F1(q_tau) - F2(q_tau))$$ Means: $$W_mu1(tau) = (p1 * f1(q_tau)) / f(q_tau), \\quad         W_mu2(tau) = ((1 - p1) * f2(q_tau)) / f(q_tau)$$ Standard deviations: $$W_sigma1(tau) = (p1 * f1(q_tau) * (q_tau - mu1) / sd1) / f(q_tau),$$ $$W_sigma2(tau) = ((1 - p1) * f2(q_tau) * (q_tau - mu2) / sd2) / f(q_tau).$$ arise derivative mixture CDF respect parameter, mapped quantile effect scale via implicit function theorem.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_normal_mixture_vqtl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build tau-by-K weights for a two-component Normal mixture with mean, variance, and membership effects — make_weights_normal_mixture_vqtl","text":"","code":"taus <- seq(0.1, 0.9, 0.1) set.seed(1) y <- c(rnorm(500, 1.2, 0.6), rnorm(500, 3.0, 0.9)) q_tau <- as.numeric(quantile(y, taus, type = 8)) W <- make_weights_normal_mixture_vqtl(   taus, q_tau,   p1 = 0.5, mu1 = 1.2, sd1 = 0.6,   mu2 = 3.0, sd2 = 0.9 ) head(W) #>             gamma  beta_mu1   beta_mu2 beta_sigma1 beta_sigma2 #> tau0.1 -0.2084154 0.9635124 0.03648760  -0.7484892 -0.09187173 #> tau0.2 -0.2684789 0.9432446 0.05675541  -0.3074682 -0.12584448 #> tau0.3 -0.3559549 0.9040579 0.09594215   0.1073999 -0.18428582 #> tau0.4 -0.4982207 0.8155360 0.18446399   0.4986371 -0.29373769 #> tau0.5 -0.7001093 0.6182523 0.38174773   0.7180740 -0.46790617 #> tau0.6 -0.8293443 0.3026462 0.69735385   0.5369821 -0.56983570"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":null,"dir":"Reference","previous_headings":"","what":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"Constructs weight matrix W maps RIF tau-slopes b(tau) effects mean variance Normal baseline phenotype.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"","code":"make_weights_vqtl(taus, q_tau, mu, sd)"},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"taus Numeric vector quantile levels (length T). q_tau Numeric vector baseline quantiles taus (length T, type=8 recommended). mu Baseline mean Y. sd Baseline standard deviation Y.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"T x 2 numeric matrix W columns: \"beta_mu\" effect SNP mean \"beta_sigma2\" effect SNP variance","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"Baseline: Y ~ N(mu, sigma^2). tau-quantiles q_tau = mu + sigma * z_tau, z_tau = Phi^-1(tau): $$ W_mu(tau) = 1, \\quad W_sigma2(tau) = z_tau / (2 * sigma). $$","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/make_weights_vqtl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build tau-by-2 weights for Normal mean/variance perturbations — make_weights_vqtl","text":"","code":"taus <- seq(0.1, 0.9, by = 0.2) y <- rnorm(2000, mean = 2, sd = 1.5) q_tau <- as.numeric(quantile(y, taus, type = 8)) W <- make_weights_vqtl(taus, q_tau, mu = mean(y), sd = sd(y)) W #>        beta_mu beta_sigma2 #> tau0.1       1  -0.4126440 #> tau0.3       1  -0.1688506 #> tau0.5       1   0.0000000 #> tau0.7       1   0.1688506 #> tau0.9       1   0.4126440"},{"path":"https://michelnivard.github.io/fungwas/reference/param_gwas.html","id":null,"dir":"Reference","previous_headings":"","what":"Parametric GWAS mapping — param_gwas","title":"Parametric GWAS mapping — param_gwas","text":"Maps quantile-level GWAS results effects user-specified parametric system parameters via weight matrix W.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/param_gwas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parametric GWAS mapping — param_gwas","text":"","code":"param_gwas(   stage1,   transform = c(\"custom_W\", \"two_normal\"),   transform_args = list(),   se_mode = c(\"diagonal\", \"plugin_cor\"),   plugin_R = NULL )"},{"path":"https://michelnivard.github.io/fungwas/reference/param_gwas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parametric GWAS mapping — param_gwas","text":"stage1 Output list quantile_gwas(). transform One : \"custom_W\" – supply weight matrix W transform_args. \"two_normal\" – construct weights two-component normal mixture. transform_args List arguments passed chosen transform: \"custom_W\": provide W (T x K). \"two_normal\": provide p1, mu1, sd1, mu2, sd2, include_membership. se_mode Standard error mode: \"diagonal\" – assume independence across taus (fast, default). \"plugin_cor\" – use plugin tau-correlation near-PD repair. plugin_R Optional T x T correlation matrix; NULL se_mode=\"plugin_cor\", estimated tau-slopes.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/param_gwas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parametric GWAS mapping — param_gwas","text":"list containing: W – weight matrix – pseudoinverse mapping matrix params – (K x P) estimated parameter effects SE_params – (K x P) delta-method standard errors R_tau – tau correlation matrix (plugin_cor)","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/param_gwas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parametric GWAS mapping — param_gwas","text":"","code":"set.seed(1) N <- 2000; P <- 20 taus <- seq(0.1, 0.9, 0.1) G <- matrix(rbinom(N * P, 2, 0.3), N, P) Y <- rnorm(N) s1 <- quantile_gwas(Y, G, taus = taus) #> Building RIF matrix... #> Computing per-SNP tau-slopes... W  <- make_weight_variance(taus, s1$q_tau, mu = mean(Y), sd = sd(Y)) #> Error in make_weight_variance(taus, s1$q_tau, mu = mean(Y), sd = sd(Y)): could not find function \"make_weight_variance\" s2 <- param_gwas(s1, transform = \"custom_W\", transform_args = list(W = W)) #> Error: object 'W' not found str(s2$params) #> Error: object 's2' not found"},{"path":"https://michelnivard.github.io/fungwas/reference/quantile_gwas.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile-level RIF GWAS — quantile_gwas","title":"Quantile-level RIF GWAS — quantile_gwas","text":"Runs genome-wide association scan user-specified quantile levels (taus) using Recentered Influence Functions (RIF). stage estimates per-tau SNP slopes naive standard errors, independent parametric system.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/quantile_gwas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile-level RIF GWAS — quantile_gwas","text":"","code":"quantile_gwas(   Y,   G,   taus = seq(0.1, 0.9, 0.05),   C = NULL,   residualize_Y = FALSE,   density_floor = 1e-08,   benchmark = TRUE,   verbose = TRUE )"},{"path":"https://michelnivard.github.io/fungwas/reference/quantile_gwas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile-level RIF GWAS — quantile_gwas","text":"Y Numeric vector (length N), phenotype. G Numeric matrix (N x P) SNP dosages genotypes. taus Numeric vector quantile levels (default seq(0.10,0.90,0.05)). C Optional N x K covariate matrix. residualize_Y Logical; TRUE, regress Y C quantiles (SNPs C ). density_floor Positive scalar; lower bound estimated densities \\(f_Y(q_tau)\\). benchmark Logical; TRUE, include timing information. verbose Logical; print progress messages.","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/quantile_gwas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile-level RIF GWAS — quantile_gwas","text":"list containing: taus – quantile levels q_tau – estimated baseline quantiles Y fhat_tau – estimated densities q_tau Q_slope – (T x P) matrix per-tau SNP slopes SE_tau – (T x P) matrix per-tau SEs timing – (benchmark=TRUE) timing breakdown","code":""},{"path":"https://michelnivard.github.io/fungwas/reference/quantile_gwas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile-level RIF GWAS — quantile_gwas","text":"","code":"set.seed(1) N <- 2000; P <- 20 taus <- seq(0.1, 0.9, 0.1) G <- matrix(rbinom(N * P, 2, 0.3), N, P) Y <- rnorm(N) res <- quantile_gwas(Y, G, taus = taus) #> Building RIF matrix... #> Computing per-SNP tau-slopes... str(res) #> List of 6 #>  $ taus    : num [1:9] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 #>  $ q_tau   : num [1:9] -1.2777 -0.8026 -0.4494 -0.1774 0.0761 ... #>  $ fhat_tau: num [1:9] 0.17 0.254 0.33 0.375 0.409 ... #>  $ Q_slope : num [1:9, 1:20] 6.77e-02 -9.07e-03 1.39e-02 -3.07e-02 1.76e-16 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:9] \"tau0.1\" \"tau0.2\" \"tau0.3\" \"tau0.4\" ... #>   .. ..$ : NULL #>  $ SE_tau  : num [1:9, 1:20] 0.0599 0.0535 0.0471 0.0443 0.0414 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:9] \"tau0.1\" \"tau0.2\" \"tau0.3\" \"tau0.4\" ... #>   .. ..$ : NULL #>  $ timing  :List of 3 #>   ..$ rif_build_sec: num 0.003 #>   ..$ gwas_loop_sec: num 0.01 #>   ..$ total_sec    : num 0.013"}]
