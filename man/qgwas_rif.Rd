% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{qgwas_rif}
\alias{qgwas_rif}
\title{RIF quantile GWAS with generic tau-to-parameter mapping}
\usage{
qgwas_rif(
  Y,
  G,
  taus = seq(0.1, 0.9, 0.05),
  C = NULL,
  residualize_Y = FALSE,
  density_floor = 1e-08,
  transform = c("custom_W", "two_normal"),
  transform_args = list(),
  se_mode = c("diagonal", "plugin_cor"),
  plugin_R = NULL,
  benchmark = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{Y}{Numeric vector (length N), outcome.}

\item{G}{Numeric matrix N x P of SNP dosages (or similar; QC/I-O not performed here).}

\item{taus}{Numeric vector of quantile levels (default \code{seq(0.10,0.90,0.05)}).}

\item{C}{Optional N x K covariate matrix.}

\item{residualize_Y}{Logical; if TRUE, regress \code{Y} on \code{C} before quantiles (and SNPs on \code{C} too).}

\item{density_floor}{Floor for estimated f_Y(q_tau).}

\item{transform}{One of \code{"custom_W"} or \code{"two_normal"}.}

\item{transform_args}{List of arguments passed to the chosen transform:
\itemize{
\item For \code{transform="custom_W"}: provide \code{W} (T x K).
\item For \code{transform="two_normal"}: provide \code{p1, mu1, sd1, mu2, sd2, include_membership} (logical).
}}

\item{se_mode}{\code{"diagonal"} (fast, default) or \code{"plugin_cor"} for delta SEs.}

\item{plugin_R}{Optional T x T correlation matrix between tau-slopes; if NULL and \code{se_mode="plugin_cor"},
it is estimated as \code{cor(t(Q_slope))} and projected to near-PD.}

\item{benchmark}{Logical; if TRUE, include timing information.}

\item{verbose}{Logical; toggle brief progress messages.}
}
\value{
A list with elements:
\itemize{
\item \code{taus, q_tau, fhat_tau}
\item \code{Q_slope} (T x P) and \code{SE_tau} (T x P)
\item \code{transform, transform_args, W} and \code{A} (pseudoinverse)
\item \code{params} (K x P) and \code{SE_params} (K x P), rownames from \code{W}
\item If \code{se_mode="plugin_cor"}, the \code{R_tau} used
\item If \code{benchmark=TRUE}, \code{timing} sublist
}
}
\description{
RIF quantile GWAS with generic tau-to-parameter mapping
}
\details{
Fast pipeline to: Build RIF(Y; tau) at user-specified \code{tau} via KDE of f_Y(q_tau).For each SNP, obtain OLS tau-slopes b(tau) and naive per-tau SEs. Map b(tau) to user-chosen parameters via W using OLS pseudoinverse
A = (W'W)^{-1} W' (no GLS). Compute delta-method SEs for the mapped parameters, using either a diagonal approximation or a plugin tau-correlation.

Covariates: by default, only the SNP is residualized on \code{C}.
If \code{residualize_Y=TRUE}, both \code{Y} and each SNP are residualized on \code{C}.

Methodology: RIF at tau uses q_tau and f_Y(q_tau) estimated via Gaussian KDE
with \code{bw.nrd0}. Per-SNP tau-slopes use closed-form OLS with per-tau residual variance for naive SEs.
The tau-to-parameter mapping uses the OLS pseudoinverse of W. Delta-method SEs are produced either
under a diagonal variance (independent tau) or using a plugin tau-correlation.
}
\examples{
set.seed(42)
N <- 5000; P <- 50
taus <- seq(0.10, 0.90, by = 0.05)
maf <- runif(P, 0.05, 0.5)
G <- matrix(rbinom(N * P, 2, rep(maf, each = N)), N, P)
# Mixture phenotype
z  <- rbinom(N, 1, 0.5)
Y  <- rnorm(N, mean = ifelse(z==1, 3.0, 1.2), sd = ifelse(z==1, 0.7, 0.45))

# Run with two_normal transform
fit <- qgwas_rif(
  Y, G, taus = taus,
  transform = "two_normal",
  transform_args = list(p1 = 0.5, mu1 = 1.2, sd1 = 0.45, mu2 = 3.0, sd2 = 0.7, include_membership = TRUE),
  se_mode = "diagonal", benchmark = FALSE, verbose = FALSE
)

# The same using custom_W
Wsame <- make_weights_normal_mixture(taus, fit$q_tau, 0.5, 1.2, 0.45, 3.0, 0.7, include_membership = TRUE)
fit2  <- qgwas_rif(
  Y, G, taus = taus,
  transform = "custom_W",
  transform_args = list(W = Wsame),
  se_mode = "diagonal", benchmark = FALSE, verbose = FALSE
)
# Estimates match up to numerical tolerance:
max(abs(fit$params - fit2$params))

}
